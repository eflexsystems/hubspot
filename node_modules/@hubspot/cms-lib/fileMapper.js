const fs = require('fs-extra');
const path = require('path');
const { default: PQueue } = require('p-queue');
const prettier = require('prettier');
const {
  ApiErrorContext,
  FileSystemErrorContext,
  logApiErrorInstance,
  logFileSystemErrorInstance,
  logErrorInstance,
} = require('./errorHandlers');
const { logger } = require('./logger');
const { getCwd, convertToLocalFileSystemPath } = require('./path');
const {
  fetchAll,
  fetchFileStream,
  fetchFolder,
  fetchModuleFolder,
} = require('./api/fileMapper');
const { Mode } = require('./lib/constants');

const BUILTINS_NAMESPACE = '@hubspot';

const MODULE_EXTENSION = '.module';

const META_KEYS_WHITELIST = new Set([
  'content_tags',
  'css_assets',
  'default',
  'editable_contexts',
  'external_js',
  'extra_classes',
  'global',
  'help_text',
  'host_template_types',
  'icon',
  'is_available_for_new_content',
  'js_assets',
  'label',
  'master_language',
  'other_assets',
  'smart_type',
  'tags',
]);

const queue = new PQueue({
  concurrency: 100,
});

function getExt(filepath) {
  if (typeof filepath !== 'string') return '';
  return path.extname(filepath).trim();
}

/**
 * @private
 * @param {string} filepath
 * @returns {boolean}
 */
function isPathToFile(filepath) {
  const ext = getExt(filepath);
  return !!ext && ext !== MODULE_EXTENSION;
}

/**
 * @private
 * @param {string} filepath
 * @returns {boolean}
 */
function isPathToModule(filepath) {
  const ext = getExt(filepath);
  return ext === MODULE_EXTENSION;
}

/**
 * @private
 * @param {string} filepath
 * @returns {boolean}
 */
function isPathToRoot(filepath) {
  if (typeof filepath !== 'string') return false;
  // Root pattern matches empty strings and: / \
  return /^(\/|\\)?$/.test(filepath.trim());
}

/**
 * Determines API `buffer` param based on mode.
 *
 * @param {Mode} mode
 */
function useApiBuffer(mode) {
  return mode === Mode.draft;
}

/**
 * @param {Mode} mode
 */
function getFileMapperApiQueryFromMode(mode) {
  return {
    buffer: useApiBuffer(mode),
  };
}

/**
 * TODO: Replace with TypeScript interface.
 * @typedef {Object} FileMapperNode A tree node from the filemapper API.
 * @property {string} path - Directory or file path.
 * @property {string|null} source - File source contents.
 * @property {number} id
 * @property {number} createdAt
 * @property {number} updatedAt
 * @property {FileMapperNode[]} children
 * @property {string} parentPath - Directory path of parent.
 * @property {boolean} folder - True if a folder, false otherwise.
 * @property {string} name - Name of file.
 */

/**
 * @private
 * @param {FileMapperNode} node
 * @throws {TypeError}
 */
function validateFileMapperNode(node) {
  if (node === Object(node)) return;
  let json;
  try {
    json = JSON.stringify(node, null, 2);
  } catch (err) {
    json = node;
  }
  throw new TypeError(`Invalid FileMapperNode: ${json}`);
}

/**
 * @callback recurseFileMapperNodeCallback
 * @param {FileMapperNode}     node
 * @param {Object}             options
 * @param {number}             options.depth
 * @param {string}             options.filepath
 * @returns {boolean} `false` to exit recursion.
 */

/**
 * @typedef {Object} FileMapperNodeMeta
 * @property {boolean} isBuiltin
 * @property {boolean} isModule
 */

/**
 * @private
 * @param {FileMapperNode} node
 * @returns {FileMapperNodeMeta}
 */
function getFileMapperNodeMeta(node) {
  return {
    isModule: !!~node.path.indexOf('.module'),
    isBuiltin: node.path.indexOf(BUILTINS_NAMESPACE) === 0,
  };
}

/**
 * Clean the meta.json file from builtin custom modules.
 *
 * @private
 * @param {string} source
 * @returns {string}
 */
function cleanMetaJson(source) {
  const meta = JSON.parse(source);
  const out = {};
  META_KEYS_WHITELIST.forEach(key => {
    if (meta[key]) {
      out[key] = meta[key];
    }
  });
  return JSON.stringify(out);
}

/**
 * Gets the `source` field from a file node and process if needed.
 *
 * @private
 * @param {FileMapperNode} node
 * @returns {string}
 */
function getFileSource(node) {
  let { source } = node;
  if (node.folder || !source) {
    return source;
  }
  const { isBuiltin, isModule } = getFileMapperNodeMeta(node);
  if (isBuiltin && isModule) {
    // Clean and format builtin module sources.
    if (node.name === 'meta.json') {
      source = cleanMetaJson(source);
    }
    if (path.extname(node.name) === '.json') {
      source = prettier.format(source, {
        parser: 'json',
      });
    }
  }
  return source;
}

/**
 * @typedef {Object} FileMapperInputArguments
 * @property {number} portalId
 * @property {string} src
 * @property {string} dest
 * @property {string} mode
 * @property {object} options
 */

/**
 * Recurse a FileMapperNode tree.
 *
 * @private
 * @param {FileMapperNode}                node
 * @param {recurseFileMapperNodeCallback} callback
 * @throws {Error}
 */
function recurseFolder(node, callback, filepath = '', depth = 0) {
  validateFileMapperNode(node);
  const isRootFolder = node.folder && depth === 0;
  if (isRootFolder) {
    if (!filepath) {
      filepath = node.name;
    }
  } else {
    filepath = path.join(filepath, node.name);
  }
  let __break = callback(node, { filepath, depth });
  if (__break === false) return __break;
  __break = node.children.every(childNode => {
    __break = recurseFolder(childNode, callback, filepath, depth + 1);
    return __break !== false;
  });
  return depth === 0 ? undefined : __break;
}

/**
 * @private
 * @async
 * @param {FileMapperInputArguments} input
 * @param {string} filepath
 * @param {FileMapperNode} node
 * @returns {Promise}
 */
async function writeUtimes(input, filepath, node) {
  try {
    const now = new Date();
    const atime = node.createdAt ? new Date(node.createdAt) : now;
    const mtime = node.updatedAt ? new Date(node.updatedAt) : now;
    await fs.utimes(filepath, atime, mtime);
  } catch (err) {
    logFileSystemErrorInstance(
      err,
      new FileSystemErrorContext({
        filepath,
        portalId: input.portalId,
        write: true,
      })
    );
  }
}

/**
 * Writes an individual file or folder (not recursive).  If file source is missing, the
 * file is fetched.
 *
 * @private
 * @async
 * @param {FileMapperInputArguments} input
 * @param {FileMapperNode}           node
 * @param {string}                   filepath
 * @returns {Promise}
 */
async function writeFileMapperNode(input, node, filepath) {
  const { portalId, options } = input;
  try {
    filepath = convertToLocalFileSystemPath(path.resolve(filepath));
    if (!options.overwrite && (await fs.pathExists(filepath))) {
      logger.log('Skipped existing "%s"', filepath);
      return;
    }
    if (node.folder) {
      await fs.ensureDir(filepath);
      logger.log('Wrote folder "%s"', filepath);
    } else {
      if (node.source != null) {
        // File fetches will include `source`
        await fs.ensureFile(filepath);
      } else {
        // Files from folder fetches will not include `source`
        [, node] = await Promise.all([
          fs.ensureFile(filepath),
          fetchFileStream(portalId, node.path, {
            qs: getFileMapperApiQueryFromMode(input.mode),
          }),
        ]);
      }
      if (typeof node.source === 'string') {
        const source = getFileSource(node);
        await fs.writeFile(filepath, source);
      }
      logger.log('Wrote file "%s"', filepath);
    }
    await writeUtimes(input, filepath, node);
  } catch (err) {
    logFileSystemErrorInstance(
      err,
      new FileSystemErrorContext({
        filepath,
        portalId: input.portalId,
        write: true,
      })
    );
  }
}

/**
 * @private
 * @async
 * @param {FileMapperInputArguments} input
 * @returns {Promise<object<boolean, boolean, boolean, boolean, FileMapperNode>>}
 */
async function fetchFromApi(input) {
  const { portalId, src, mode } = input;
  const isModule = isPathToModule(src);
  const isFile = !isModule && isPathToFile(src);
  const isRoot = !isModule && !isFile && isPathToRoot(src);
  const isFolder = !isFile;
  let node;
  try {
    const fetch =
      (isModule && fetchModuleFolder) ||
      (isFile && fetchFileStream) ||
      (isRoot && fetchAll) ||
      fetchFolder;
    node = await fetch(portalId, src, {
      qs: getFileMapperApiQueryFromMode(mode),
    });
    logger.log('Fetched "%s" from portal %d successfully', src, portalId);
  } catch (err) {
    logApiErrorInstance(
      err,
      new ApiErrorContext({
        portalId,
        request: src,
      })
    );
  }
  return { isFile, isFolder, isModule, isRoot, node };
}

/**
 * @private
 * @async
 * @param {FileMapperInputArguments} input
 * @param {FileMapperNode}           node
 * @returns {Promise}
 */
async function writeFileDownload(input, node) {
  let destPath;
  try {
    const dest = path.resolve(input.dest);
    destPath = isPathToFile(dest)
      ? dest
      : convertToLocalFileSystemPath(path.resolve(dest, node.name));
    await queue.add(() => writeFileMapperNode(input, node, destPath));
  } catch (err) {
    logErrorInstance(err, {
      portalId: input.portalId,
    });
  }
}

/**
 * @private
 * @async
 * @param {FileMapperInputArguments} input
 * @param {FileMapperNode}           node
 * @returns {Promise}
 */
async function writeFolderDownload(input, node) {
  let rootPath;
  try {
    const dest = path.resolve(input.dest);
    rootPath =
      dest === getCwd()
        ? convertToLocalFileSystemPath(path.resolve(dest, node.name))
        : dest;
    recurseFolder(
      node,
      (childNode, { filepath }) => {
        queue.add(() => writeFileMapperNode(input, childNode, filepath));
      },
      rootPath
    );
  } catch (err) {
    logErrorInstance(err, {
      portalId: input.portalId,
    });
  }
}

/**
 * Fetch a file/folder and write to local file system.
 *
 * @async
 * @param {FileMapperInputArguments} input
 * @returns {Promise}
 */
async function downloadFileOrFolder(input) {
  try {
    const { isFile, node } = await fetchFromApi(input);
    if (node) {
      if (isFile) {
        await writeFileDownload(input, node);
      } else {
        await writeFolderDownload(input, node);
      }
      await queue.onIdle();
      logger.log('Completed fetch of "%s" to "%s"', input.src, input.dest);
    }
  } catch (err) {
    logger.error('Error fetching "%s" to "%s"', input.src, input.dest);
    logErrorInstance(err, {
      portalId: input.portalId,
    });
  }
}

module.exports = {
  isPathToFile,
  isPathToModule,
  isPathToRoot,
  downloadFileOrFolder,
  recurseFolder,
  getFileMapperApiQueryFromMode,
  fetchFromApi,
};
